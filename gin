为了提高密钥的安全性，可以在每次请求中随机生成 AES-256 密钥，并使用 RSA 加密将 AES 密钥传输到客户端。这样可以同时利用对称加密（AES-256）和非对称加密（RSA）来保证数据的安全性。

下面是具体实现思路：

	1.	生成随机 AES-256 密钥：在每次请求时生成一个随机的 AES-256 密钥。
	2.	使用 RSA 加密 AES 密钥：将 AES 密钥用 RSA 加密，客户端可以通过公钥解密获得 AES 密钥。
	3.	加密和解密数据：用随机生成的 AES 密钥加密传输数据，确保数据的机密性。
	4.	返回加密数据和加密的 AES 密钥：服务器返回加密后的响应数据和用 RSA 加密的 AES 密钥。

1. 使用 RSA 生成密钥对

我们首先需要生成 RSA 的密钥对（公钥和私钥）。RSA 私钥留在服务器，公钥用于加密传输到客户端的 AES 密钥。

package main

import (
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"encoding/pem"
	"os"
)

// 生成 RSA 密钥对并保存为 PEM 文件
func generateRSAKeyPair(bits int) (*rsa.PrivateKey, *rsa.PublicKey, error) {
	// 生成私钥
	privateKey, err := rsa.GenerateKey(rand.Reader, bits)
	if err != nil {
		return nil, nil, err
	}

	// 将私钥保存为 PEM 格式
	privateKeyFile, err := os.Create("private.pem")
	if err != nil {
		return nil, nil, err
	}
	defer privateKeyFile.Close()

	privateKeyPEM := pem.EncodeToMemory(
		&pem.Block{
			Type:  "RSA PRIVATE KEY",
			Bytes: x509.MarshalPKCS1PrivateKey(privateKey),
		},
	)
	privateKeyFile.Write(privateKeyPEM)

	// 导出公钥
	publicKey := &privateKey.PublicKey
	publicKeyFile, err := os.Create("public.pem")
	if err != nil {
		return nil, nil, err
	}
	defer publicKeyFile.Close()

	publicKeyBytes, err := x509.MarshalPKIXPublicKey(publicKey)
	if err != nil {
		return nil, nil, err
	}

	publicKeyPEM := pem.EncodeToMemory(
		&pem.Block{
			Type:  "RSA PUBLIC KEY",
			Bytes: publicKeyBytes,
		},
	)
	publicKeyFile.Write(publicKeyPEM)

	return privateKey, publicKey, nil
}

你可以通过运行这段代码生成 private.pem 和 public.pem 文件。公钥可以分发给客户端，私钥留在服务器。

2. 加密 AES 密钥的函数

我们将 AES-256 密钥用 RSA 公钥加密，并在返回响应数据时附上加密后的 AES 密钥。

import (
	"crypto/rsa"
	"crypto/rand"
	"crypto/x509"
	"encoding/pem"
	"errors"
	"os"
)

// 读取 RSA 公钥
func loadPublicKey(path string) (*rsa.PublicKey, error) {
	pubKeyFile, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	block, _ := pem.Decode(pubKeyFile)
	if block == nil || block.Type != "RSA PUBLIC KEY" {
		return nil, errors.New("failed to decode PEM block containing public key")
	}

	publicKey, err := x509.ParsePKIXPublicKey(block.Bytes)
	if err != nil {
		return nil, err
	}

	rsaPubKey, ok := publicKey.(*rsa.PublicKey)
	if !ok {
		return nil, errors.New("not RSA public key")
	}

	return rsaPubKey, nil
}

// 使用 RSA 公钥加密 AES 密钥
func encryptWithRSA(publicKey *rsa.PublicKey, data []byte) ([]byte, error) {
	return rsa.EncryptPKCS1v15(rand.Reader, publicKey, data)
}

3. 修改加密中间件

修改 AES-256 中间件，随机生成 AES 密钥并用 RSA 公钥加密，将加密后的 AES 密钥一起返回给客户端。

package main

import (
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/base64"
	"io"
	"io/ioutil"
	"net/http"

	"github.com/gin-gonic/gin"
)

// AES-256 加密函数
func encryptAES256(plaintext []byte, key []byte) (string, error) {
	block, err := aes.NewCipher(key)
	if err != nil {
		return "", err
	}

	aesGCM, err := cipher.NewGCM(block)
	if err != nil {
		return "", err
	}

	nonce := make([]byte, aesGCM.NonceSize())
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return "", err
	}

	ciphertext := aesGCM.Seal(nonce, nonce, plaintext, nil)
	return base64.StdEncoding.EncodeToString(ciphertext), nil
}

// AES-256 解密函数
func decryptAES256(ciphertext string, key []byte) ([]byte, error) {
	data, err := base64.StdEncoding.DecodeString(ciphertext)
	if err != nil {
		return nil, err
	}

	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	aesGCM, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	nonceSize := aesGCM.NonceSize()
	nonce, ciphertext := data[:nonceSize], data[nonceSize:]

	plaintext, err := aesGCM.Open(nil, nonce, ciphertext, nil)
	if err != nil {
		return nil, err
	}

	return plaintext, nil
}

// 中间件实现
func EncryptionMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		// 加载 RSA 公钥
		publicKey, err := loadPublicKey("public.pem")
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to load RSA public key"})
			c.Abort()
			return
		}

		// 随机生成 AES-256 密钥
		aesKey := make([]byte, 32)
		if _, err := rand.Read(aesKey); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to generate AES key"})
			c.Abort()
			return
		}

		// 解密请求体
		if c.Request.Method == http.MethodPost || c.Request.Method == http.MethodPut {
			body, err := ioutil.ReadAll(c.Request.Body)
			if err != nil {
				c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request"})
				c.Abort()
				return
			}

			decryptedData, err := decryptAES256(string(body), aesKey)
			if err != nil {
				c.JSON(http.StatusBadRequest, gin.H{"error": "failed to decrypt data"})
				c.Abort()
				return
			}

			c.Request.Body = ioutil.NopCloser(bytes.NewBuffer(decryptedData))
		}

		c.Next()

		// 加密响应体
		if c.Writer.Status() == http.StatusOK {
			respBody, err := ioutil.ReadAll(c.Writer.Body)
			if err == nil && len(respBody) > 0 {
				encryptedData, err := encryptAES256(respBody, aesKey)
				if err == nil {
					// 加密 AES 密钥并返回给客户端
					encryptedKey, err := encryptWithRSA(publicKey, aesKey)
					if err == nil {
						c.Header("Encrypted-Key", base64.StdEncoding.EncodeToString(encryptedKey))
					}
					c.Writer.Write([]byte(encryptedData))
				}
			}
		}
	}
}

4. 完整的示例

package main

import (
	"github.com/gin-gonic/gin"
	"net/http"
)

func main() {
	r := gin.Default()

	// 使用加密中间件
	r.Use(EncryptionMiddleware())

	// 示例路由
	r.POST("/data", func(c *gin.Context) {
		var json struct {
			Message string `json:"message"`
		}

		if err := c.ShouldBindJSON(&json); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "invalid data"})
			return
		}

		c.JSON(http.StatusOK, gin.H{
			"received": json.Message,
		})
	})

	r.Run(":8080")
}

5. 客户端流程

	•	RSA 公钥加密 AES 密钥：客户端使用服务端提供的 RSA 公钥解密服务器返回的 Encrypted-Key，然后用解密后的 AES 密钥解密数据。
	•	AES 数据加密解密：客户端发送加密数据，并且接收加密响应。

这个实现确保了 AES 密钥的传输是安全的，同时使用对称加密提高了性能。